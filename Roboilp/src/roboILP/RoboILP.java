///////////////////////////////////////////////////////////////////////////
// Copyright (C) 2008
//
// File:	RoboILP.java
// Author:	Alan Wai
// Date:	Jun 28, 2008
//
// File Description:
//	This is the main body of the RoboILP Team.
//
///////////////////////////////////////////////////////////////////////////

package roboILP;

import com.declarativa.interprolog.*;
import com.xsb.interprolog.*;

import java.io.*;
import java.net.*;
import java.util.*;
import java.awt.geom.*;
import java.awt.geom.Point2D.*;

//***************************************************************************
//
// This is main object class
//
//***************************************************************************
class RoboILP implements SendCommand {
	// ===========================================================================
	// Initialization member functions

	// ---------------------------------------------------------------------------
	// The main appllication function.
	// Command line format:
	//
	// roboILP [-parameter value]
	//
	// Parameters:
	//
	// host (default "localhost")
	// The host name can either be a machine name, such as "java.sun.com"
	// or a string representing its IP address, such as "206.26.48.100."
	//
	// port (default 6000)
	// Port number for communication with server
	//
	// team (default "roboILP")
	// Team name. This name can not contain spaces.
	//
	// theory (default "roboILP.t")
	// File containing all the theories generated by CLAUDIEN given a set of
	// test models.
	//
	// modelFile
	// models to be used (created or read)
	//
	// mode (default 0 - Normal)
	// Measurement Mode - 1
	//
	// rawFile
	// Robocup raw data logs
	//
	// sceneSel (default 0 - ChooseFirstValid)
	// ChooseKickPriority - 1
	// ChooseActionPriority - 2
	// VoteEqualWeighted - 3
	// VoteWeighted - 4
	//
	// distCal (default 0 - SimpleBallDistance)
	// NearestNeighborBallDistance - 1
	// NearestNeighborCellBallDistance - 2
	// NearestNeighborBallGoalDistance - 3
	// NearestNeighborCartesianObjects - 4
	// NearestNeighborCartesianAllObjects - 5
	// NearestNeighborCartesianCellObjects - 6
	//
	// numBest (default 1)
	// # of best clauses used for voting
	//
	// numScenes (default 6000)
	// # of scenes to compare with database
	//
	// pp (default 0)
	// Turn on post-processing
	//

	public static boolean println(int verbosity, String msg) {
		if (m_verbosity >= verbosity) {
			long time = System.currentTimeMillis() - m_startTime;
			System.out.println("[Java " + time + "ms]: " + msg + "("
					+ Thread.currentThread() + ")");
		}
		return (m_verbosity >= verbosity);
	}

	public static void main(String a[]) throws SocketException, IOException {
		String hostName = new String("localhost");
		int port = 6000;
		String team = new String("RoboILP");
		int mode = 0;
		int sceneSel = 0;
		int distCal = 0;
		boolean writeModel = false;
		boolean randomModels = true;
		boolean useAllModels = false;
		String modelFile = new String("");
		String theoryFile = new String("");
		String rawFile = new String("");
		Vector rawFiles = new Vector();
		int nNumRawFiles = -1;
		String rawFilesPrefix = new String();
		int numBest = 1;
		int numScenes = 6000;
		int pp = 0;
		int fold = 0;
		int tsize = -1;
		int maxActionCnt = -1;
		long seed = 12345;
		boolean debug = false;
		double x = 0.0;
		double y = 0.0;
		int CVthreshold = 66; // percentage of label instance / fold must be
		// int CVthreshold = 20; // percentage of label instance / fold must be
		// greater than CVthreshold*tsize for using
		// reverse CV

		try {
			// First look for parameters
			for (int c = 0; c < a.length; c += 2) {
				if (a[c].compareTo("-host") == 0) {
					hostName = a[c + 1];
				} else if (a[c].compareTo("-port") == 0) {
					port = Integer.parseInt(a[c + 1]);
				} else if (a[c].compareTo("-team") == 0) {
					team = a[c + 1];
				} else if (a[c].compareTo("-theory") == 0) {
					theoryFile = a[c + 1];
				} else if (a[c].compareTo("-writeModel") == 0) {
					int write = Integer.parseInt(a[c + 1]);
					writeModel = (write == 1);
				} else if (a[c].compareTo("-modelFile") == 0) {
					modelFile = a[c + 1];
				} else if (a[c].compareTo("-mode") == 0) {
					mode = Integer.parseInt(a[c + 1]);
				} else if (a[c].compareTo("-CVthreshold") == 0) {
					CVthreshold = Integer.parseInt(a[c + 1]);
				} else if (a[c].compareTo("-fold") == 0) {
					fold = Integer.parseInt(a[c + 1]);
				} else if (a[c].compareTo("-tsize") == 0) {
					tsize = Integer.parseInt(a[c + 1]);
				} else if (a[c].compareTo("-seed") == 0) {
					seed = Long.parseLong(a[c + 1]);
				} else if (a[c].compareTo("-useAllModels") == 0) {
					int useModels = Integer.parseInt(a[c + 1]);
					useAllModels = (useModels == 1);
				} else if (a[c].compareTo("-randomModels") == 0) {
					int random = Integer.parseInt(a[c + 1]);
					randomModels = (random == 1);
				} else if (a[c].compareTo("-rawFiles") == 0) {
					// rawFile = a[c+1];
					rawFiles.addElement(a[c + 1]);
				} else if (a[c].compareTo("-rawFilesPrefix") == 0) {
					rawFilesPrefix = a[c + 1];
				} else if (a[c].compareTo("-numRawFiles") == 0) {
					nNumRawFiles = Integer.parseInt(a[c + 1]);
				} else if (a[c].compareTo("-sceneSel") == 0) {
					sceneSel = Integer.parseInt(a[c + 1]);
				} else if (a[c].compareTo("-distCal") == 0) {
					distCal = Integer.parseInt(a[c + 1]);
				} else if (a[c].compareTo("-numScenes") == 0) {
					numScenes = Integer.parseInt(a[c + 1]);
				} else if (a[c].compareTo("-numBest") == 0) {
					numBest = Integer.parseInt(a[c + 1]);
				} else if (a[c].compareTo("-pp") == 0) {
					pp = Integer.parseInt(a[c + 1]);
				} else if (a[c].compareTo("-maxActionCnt") == 0) {
					maxActionCnt = Integer.parseInt(a[c + 1]);
				} else if (a[c].compareTo("-v") == 0) {
					m_verbosity = Integer.parseInt(a[c + 1]);
				} else if (a[c].compareTo("-debug") == 0) {
					debug = true;
				} else if (a[c].compareTo("-x") == 0) {
					x = java.lang.Double.parseDouble(a[c + 1]);
				} else if (a[c].compareTo("-y") == 0) {
					y = java.lang.Double.parseDouble(a[c + 1]);
				} else {
					throw new Exception();
				}
			}
		} catch (Exception e) {
			System.err.println("");
			System.err.println("RoboILP version 2.0");
			System.err.println("USAGE: roboILP.RoboILP [-parameter value]");
			System.err.println("");
			System.err.println("    Parameters  value        default");
			System.err.println("   ------------------------------------");
			System.err.println("    host        host_name    localhost");
			System.err.println("    port        port_number  6000");
			System.err.println("    team        team_name    Kris");
			System.err.println("    theory      String	 roboILP.t");
			System.err.println("    scene       String	 0");
			System.err.println("    sceneSel    int		 0");
			System.err.println("    distCal	    int		 0");
			System.err.println("    numBest     numBest      5");
			System.err.println("    numScenes   numScenes    6000");
			System.err.println("    pp	    bool	 0");
			System.err.println("");
			System.err.println("    Example:");
			System.err
					.println("      roboILP -host www.host.com -port 6000 -team Goofy");
			System.err.println("    or");
			System.err.println("      roboILP -host 193.117.005.223");
			return;
		}

		System.out.println("Running with parameters:");
		System.out.println("host: " + hostName);
		System.out.println("port: " + port);
		System.out.println("team: " + team);
		System.out.println("mode: " + mode);
		System.out.println("randomModel: " + randomModels);
		System.out.println("useAllModels: " + useAllModels);
		System.out.println("writeModel: " + writeModel);
		System.out.println("Output DB: " + modelFile);
		System.out.println("theory file: " + theoryFile);
		System.out.println("scene file: " + rawFiles);
		// System.out.println("sceneSel: " + sceneSelAlgos[sceneSel] + " (" +
		// sceneSel + ")");
		// System.out.println("distCal: " + distCalAlgos[distCal] + " (" +
		// distCal + ")");
		System.out.println("numBest: " + numBest);
		System.out.println("numScenes: " + numScenes);
		System.out.println("pp: " + pp);
		System.out.println("fold: " + fold);
		System.out.println("tsize: " + tsize);
		System.out.println("verbose: " + m_verbosity);
		System.out.println("maxActionCnt: " + maxActionCnt);
		System.out.println("debug: " + debug);

		RoboILP player = new RoboILP(InetAddress.getByName(hostName), port,
				team, theoryFile, writeModel, modelFile, mode, rawFiles,
				rawFilesPrefix, nNumRawFiles, randomModels, useAllModels,
				numBest, numScenes, pp, fold, tsize, CVthreshold, seed,
				maxActionCnt, debug, x, y);

		// enter main loop
		player.mainLoop();

		System.exit(0);

	}

	// ---------------------------------------------------------------------------
	// This constructor opens socket for connection with server
	public RoboILP(InetAddress host, int port, String team, String theoryFile,
			boolean writeModel, String modelFile, int mode, Vector rawFiles,
			String rawFilesPrefix, int nNumRawFiles, boolean randomModels,
			boolean useAllModels, int numBest, int numScenes, int pp, int fold,
			int tsize, int CVthreshold, long seed, int maxActionCnt,
			boolean debug, double x, double y) throws SocketException {
		m_socket = new DatagramSocket();
		m_host = host;
		m_port = port;
		m_team = team;
		m_mode = mode;
		m_bRandomModels = randomModels;
		m_bUseAllModels = useAllModels;
		m_maxActionCnt = maxActionCnt;
		m_theory = theoryFile;
		m_bWriteModel = writeModel;
		m_modelFile = modelFile;
		m_rawFiles = rawFiles;
		m_rawFilesPrefix = rawFilesPrefix;
		m_nNumRawFiles = nNumRawFiles;
		m_numBest = numBest;
		m_numScenes = numScenes;
		m_pp = pp;
		m_fold = fold;
		m_tsize = tsize;
		m_CVthreshold = CVthreshold;
		m_nMinFraction = 0.1;
		m_seed = seed;
		m_debug = debug;
		m_x = x;
		m_y = y;

		m_randomGen = new Random();
		m_randomGen.setSeed(m_seed);
		m_startTime = System.currentTimeMillis();
	}

	// ---------------------------------------------------------------------------
	// This destructor closes socket to server
	public void finalize() {
		m_socket.close();
//		m_brain.shutdown();
	}

	// ---------------------------------------------------------------------------
	// This is main loop for player
	protected void mainLoop() throws IOException {
		String domainFile = "domainFile";

		//
		// Create Controller, Brain and Memory
		//
		m_brain = new ILPBrain(this, m_mode, m_theory, m_numBest, m_numScenes,
				m_pp, m_debug, m_x, m_y);
		m_memory = new Memory(true);
		m_ctrl = new RobocupController(m_mode, m_brain, m_memory, m_team,
				m_bUseAllModels, m_maxActionCnt);

		if (m_mode == RoboILP.MODE_RUN) {

			// ////////////////////////////////////////////////////////////////////////
			// RUN MODE
			// ////////////////////////////////////////////////////////////////////////

			byte[] buffer = new byte[MSG_SIZE];
			DatagramPacket packet = new DatagramPacket(buffer, MSG_SIZE);

			System.out.println("Calling init...");
			// first we need to initialize connection with server
			init();
			System.out.println("init done.");

			m_socket.receive(packet);
			m_port = packet.getPort();

			// first put it somewhere on my side
			double x, y;
			if (m_x == 0.0 && m_y == 0.0) {
				x = -Math.random() * 52.5;
				y = Math.random() * 34.0;
			} else {
				x = m_x;
				y = m_y;
			}
			System.out.println("Player moved to x: " + x + ", y: " + y);
			move(x, y);
			System.out.println("Player moved to x: " + x + ", y: " + y);
			move(x, y);
			System.out.println("Player moved to x: " + x + ", y: " + y);
			move(x, y);

			// Now we should be connected to the server
			while (true) {
				RoboILP.println(3, "parseSensorInformation begin...");
				parseSensorInformation(receive());
				RoboILP.println(3, "parseSensorInformation finished...");
			}
		} else {

			// ////////////////////////////////////////////////////////////////////////
			// Generation and Test MODE
			// ////////////////////////////////////////////////////////////////////////

			//
			// Convert the scenes into models
			// The model file will be overwritten only if writeModel is true.
			//
			if (m_mode == MODE_GENERATION) {
				m_modelStrings = new Vector();
				loadRawFile(m_rawFiles);
				//
				// Dec 28, 2008
				// Split the data set into training and testing for k-fold CV
				if (m_fold != 0) {
					// splitDataSets(m_modelStrings);
				}
			}
			if (m_mode == MODE_TEST) {
				//
				// Sep 20, 2010
				// We can use loadRawFile instead to load the raw data files,
				// convert
				// them into models and send it to the brain. Doing that can
				// also
				// measure the time needed more accurately. But using
				// loadModelFile
				// is more straight-forward.
				loadModelFile(m_modelFile);
			}
		} // else

//		m_brain.shutdown();
	} // mainLoop

	/*public static void callProlog() {
		String path = "/ws/awai-ott/mystuffs/XSB/config/i686-pc-linux-gnu/bin/";
		PrologEngine engine = new NativeEngine(path + "xsb", true);
		engine.command("import append/3 from basics"); // Only for XSB Prolog
		engine.command("dynamic dirQl/2"); // Only for XSB Prolog
		engine.command("dynamic distQl/2"); // Only for XSB Prolog
		engine.command("consult('imisys.rules')");

		Object[] bindings = engine
				.deterministicGoal(
						"asserta(distQl(1,Object)),asserta(dirQl(1,Object)),action(1,Action,P1,P2,CN)",
						"[string[Object)]", new Object[] { "p1" },
						"[string(Action),string(P1),string(P2),string(CN)]");

		// Results returned from Prolog
		String strAction = (String) bindings[0];
		String P1 = (String) bindings[1];
		String P2 = (String) bindings[2];
		String CN = (String) bindings[3];

		RoboILP.println(1, "[RoboILP::think] cycle(0): action(" + strAction
				+ "," + P1 + "," + P2 + ")");

	}*/

	// ---------------------------------------------------------------------------
	// This function parses sensor information
	private void parseSensorInformation(String message) {
		//
		// Currently, server.conf specifies send_step to be 100ms, meaning
		// this function is called once every 100ms.
		//
		m_ctrl.execute(message);
	}

	// ===========================================================================
	// Implementation of SendCommand Interface

	// ---------------------------------------------------------------------------
	// This function sends move command to the server
	// TODO: move these to RobocupController
	public void move(double x, double y) {
		send("(move " + java.lang.Double.toString(x) + " "
				+ java.lang.Double.toString(y) + ")");
	}

	public void say(String message) {
		send("(say " + message + ")");
	}

	public void changeView(String angle, String quality) {
		send("(change_view " + angle + " " + quality + ")");
	}

	// TODO: move this to RobocupController
	// ===========================================================================
	// Here comes collection of communication function
	// ---------------------------------------------------------------------------
	// This function sends initialization command to the server
	private void init() {
		// send("(init " + m_team + " (version 9.4.5))");
		send("(init " + m_team + ")");
	}

	// ---------------------------------------------------------------------------
	// This function sends via socket message to the server
	public void send(String message) {
		byte[] buffer = null;
		buffer = message.getBytes();

		// System.out.println("message: " + message);
		// System.out.println("buffer.length: " + buffer.length);

		// DatagramPacket packet = new DatagramPacket(buffer, MSG_SIZE, m_host,
		// m_port);
		DatagramPacket packet = new DatagramPacket(buffer, buffer.length,
				m_host, m_port);

		try {
			m_socket.send(packet);
		} catch (IOException e) {
			System.err.println("socket sending error " + e);
		}
	}

	// ---------------------------------------------------------------------------
	// This function waits for new message from server
	private String receive() {
		byte[] buffer = new byte[MSG_SIZE];
		DatagramPacket packet = new DatagramPacket(buffer, MSG_SIZE);
		String result = null;

		try {
			m_socket.receive(packet);
		} catch (IOException e) {
			System.err.println("socket receiving error " + e);
		}

		try {
			result = new String(buffer, "US-ASCII");
		} catch (UnsupportedEncodingException e) {
			System.err.println("named charset is not supported" + e);
		}
		return result;
	}

	public void loadRawFile(Vector rawFiles) {

		try {
			FileOutputStream modelFileOut = null;
			OutputStreamWriter modelWriter = null;
			PrintWriter modelPrinter = null;

			if (m_bWriteModel) {
				modelFileOut = new FileOutputStream(m_modelFile);
				modelWriter = new OutputStreamWriter(modelFileOut, "US-ASCII");
				modelPrinter = new PrintWriter(modelWriter); // throws exception
			}

			Iterator it = rawFiles.iterator();
			int numRawFiles = (m_nNumRawFiles != -1) ? m_nNumRawFiles
					: rawFiles.size();

			for (int i = 0; i < numRawFiles; i += 1) {
				int numModelsWritten = 0;
				String rawFile;

				int j = i + 1;
				if (m_nNumRawFiles != -1) {
					rawFile = new String(m_rawFilesPrefix + "_" + j + ".lsf");
				} else {
					rawFile = (String) it.next();
				}

				RoboILP.println(1, "Loading raw file: " + rawFile);
				FileInputStream fileIn = new FileInputStream(rawFile);
				BufferedReader bufReader = new BufferedReader(
						new InputStreamReader(fileIn));

				m_ctrl.reset();
				m_brain.reset();
				m_memory.reset();

				do {
					String readStr = bufReader.readLine();
					RoboILP.println(3, "raw file str: " + readStr);

					m_ctrl.execute(readStr);
					if (m_bWriteModel && m_ctrl.isModelValid()) {
						String modelString = m_ctrl.popModel();

						Action action = m_ctrl.getAction();
						String actionStr = action.getAction();

						if (m_bUseAllModels == false) {

							if (m_seed == j) {
								// write all models except kick actions for this
								// player
								if (actionStr.compareTo("kick") != 0) {
									modelPrinter.println(modelString);
									numModelsWritten++;
								} else {
									RoboILP.println(3, "skipping kick @"
											+ m_ctrl.getCurrentCycle());
								}
							} else {
								// write only models with kick actions for all
								// other players
								if (actionStr.compareTo("kick") == 0) {
									// replace the currentCycle with new tag
									int oldTag = m_ctrl.getCurrentCycle();
									int tag = oldTag + j * 10000;
									RoboILP.println(3, "adding kick @" + oldTag);
									RoboILP.println(3, "oldTag=" + oldTag
											+ "; newTag=" + tag);
									String oldTagStr = "\\(" + oldTag;
									String newTagStr = "\\(" + tag;
									String newStr = modelString.replaceAll(
											oldTagStr, newTagStr);
									modelPrinter.println(newStr);
								}
							}

							// if(m_fold != 0) {
							// m_modelStrings.add(new String(modelString));
							// }
						} else { // m_bUseAllModels == true}
							// don't skip kicks
							modelPrinter.println(modelString);
							numModelsWritten++;
						}

					} // m_bWriteModel

				} while (bufReader.ready()
						&& (m_tsize == -1 || numModelsWritten != m_tsize));

				bufReader.close();
				fileIn.close();
			}

			// m_ctrl.printStatistics();

			if (m_bWriteModel) {
				modelPrinter.close();
				modelWriter.close();
				modelFileOut.close();
			}

		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		} catch (Exception e) {
			e.printStackTrace();
		}

	}

	public void loadModelFile(String fname) {
		//
		//

		System.out.println("Loading models from file " + fname);
		try {
			FileInputStream fileIn = new FileInputStream(fname);
			BufferedReader bufReader = new BufferedReader(
					new InputStreamReader(fileIn));
			int iteration = 0;
			boolean startAccumulate = false;
			String strModelToTest = "";
			int currentCycle = 0;

			do {

				String readStr = bufReader.readLine();
				RoboILP.println(3, "Loading model: readStr: " + readStr);
				// Accumulate the whole scene into one string first
				if (readStr.startsWith("key", 0)) {
					int bracketIdx = readStr.indexOf("(");
					currentCycle = Integer.valueOf(
							readStr.substring(bracketIdx + 1,
									readStr.length() - 2)).intValue();
					strModelToTest = "asserta("
							+ readStr.substring(0, readStr.length() - 1) + "),";
					startAccumulate = true;
				} else if (readStr.startsWith("actionQn", 0)) {
					// do nothing
				} else if (readStr.startsWith("end", 0)) {
					// try {
					// RoboILP.println(3,"sleep for 10ms...");
					// Thread.sleep(50);
					// } catch(Exception e){}
					m_brain.think(strModelToTest, currentCycle);
					startAccumulate = false;
					strModelToTest = "";
				} else if (startAccumulate) {
					strModelToTest += "asserta("
							+ readStr.substring(0, readStr.length() - 1) + "),";
				}

				if (iteration == 100)
					System.gc();
				iteration++;
			} while (bufReader.ready());

			RoboILP.println(3, "End of model file");
			m_brain.printStats();

			bufReader.close();
			fileIn.close();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	// ------------------------------------------------------------------------------
	// class memebers

	private DatagramSocket m_socket; // Socket to communicate with server
	private InetAddress m_host; // Server address
	private int m_port; // server port
	private ILPBrain m_brain; // Brain for inputs processing
	private Memory m_memory; // Memory for objects storage
	private Controller m_ctrl; // Controller

	// constants
	private static int m_verbosity = 0;
	private static final int MSG_SIZE = 4096; // Size of socket buffer
	private static final String[] sceneSelAlgos = { "ChooseFirstValid",
			"ChooseKickPriority", "ChooseActionPriority", "VoteEqualWeighted",
			"VoteWeighted" };
	private static final String[] distCalAlgos = { "SimpleBallDistance",
			"NearestNeighborBallDistance", "NearestNeighborCellBallDistance",
			"NearestNeighborBallGoalDistance",
			"NearestNeighborCartesianObjects",
			"NearestNeighborCartesianAllObjects",
			"NearestNeighborCartesianCellObjects",
			"NearestNeighborLayeredCartesianObjects" };

	// parameters
	private int m_mode; // Measurement mode (1)
	private int m_sceneSel; // Scene Selection algo
	private int m_distCal; // Distance Calculation algo
	private String m_theory;; // RoboILP theory file
	private boolean m_bWriteModel; // whether model file should be overwritten
	private boolean m_bRandomModels;// whether models are picked randomly from
									// files
	private double m_nMinFraction;// whether models are picked randomly from
									// files
	private boolean m_bUseAllModels;// regardless whether absPos can be
									// calculated.
	private String m_modelFile; // model file to be read or written
	private Vector m_rawFiles; // vectors of rawFiles for conversion
	private String m_rawFilesPrefix; // used along with m_nNumRawFiles
	private int m_nNumRawFiles; // used along with m_rawFilesPrefix
	private int m_numBest; // # of best scenes to return
	private int m_numScenes; // # of scenes to compare
	private int m_pp;
	private int m_fold; // number of k-folds CV
	private int m_tsize; // size of training data set
	private int m_CVthreshold; // percentage of label instance / fold must be
	// greater than CVthreshold*tsize for using
	private int m_maxActionCnt;
	private Vector m_modelStrings;
	private long m_seed;
	private boolean m_debug;
	private java.util.Random m_randomGen;
	public static long m_startTime;
	private double m_x;
	private double m_y;

	//
	// Robocup specific parameters
	//
	private String m_team; // team name

	//
	// Spatial domain parameters
	//
	// private Point2D.Double [] m_flags;
	// private int m_numFlags;

	//
	// static values
	//
	public static final int DOMAINFILE_NONE = 0;
	public static final int DOMAINFILE_FLAGS = 1;
	public static final int DOMAINFILE_MISC = 3;

	//
	// TODO: explanations
	//
	public static final int MODE_RUN = 0;
	public static final int MODE_TRAIN = 1;
	public static final int MODE_TEST = 2;
	public static final int MODE_GENERATION = 3;

}
